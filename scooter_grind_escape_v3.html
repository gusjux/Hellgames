<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Scooter Grind Escape — Hellride</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      touch-action: none; /* блокируем скролл/зум жестами */
    }
    #app {
      width: 100%;
      height: 100%;
      position: relative;
    }
    canvas { display: block; }
    .ui-button {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 20px;
      font-size: 20px;
      color: #fff;
      background: #ff6600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    .start-btn { top: 50%; }
    .restart-btn { bottom: 20%; }
    .score-display {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 22px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      letter-spacing: .3px;
    }
  </style>
</head>
<body>
<div id="app"></div>

<script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
<script>
/* Scooter Grind Escape — версия 3
   Изменения против v2:
   - Прыжок длится на ~50% дольше (JUMP_SPEED ↓).
   - Присед держится дольше (DUCK_DURATION_MS ↑) + авто-продление,
     пока верхняя перекладина не пройдёт игрока.
*/

const { createApp, ref, onMounted, onBeforeUnmount } = Vue;

createApp({
  setup() {
    const gameState = ref("start"); // start | play | end
    const score = ref(0);           // "метры"
    const finalScore = ref(0);
    const canvas = ref(null);
    let ctx;

    // Игровые переменные
    let groundY;
    let obstacles = [];
    let speed = 4.2;
    let speedLevel = 0;
    let distance = 0;
    let startTs = 0;
    let lastTs = 0;
    let rafId = null;
    let obstacleTimerId = null;

    // Игрок
    const player = {
      x: 0, y: 0,
      state: "ride",      // 'ride' | 'jump' | 'duck'
      jumpT: 0,           // прогресс прыжка 0..1
      duckUntil: 0        // время (ms), до которого держим 'duck'
    };

    // Константы прыжка/управления
    const JUMP_HEIGHT = 230;          // амплитуда прыжка
    const JUMP_SPEED  = 1.8;          // БЫЛО 2.25 — теперь в 1.5 раза медленнее => ~+50% длительность
    const DUCK_DURATION_MS = 1100;     // БЫЛО 450 — держим дольше

    // Ввод (свайпы)
    let touchStartX = 0, touchStartY = 0, touchActive = false, gestureUsed = false;

    // --- Жизненный цикл ------------------------------------------------------
    const startGame = () => {
      obstacles = [];
      clearTimeout(obstacleTimerId);
      speed = 4.2;
      speedLevel = 0;
      distance = 0;
      score.value = 0;
      player.state = "ride";
      player.jumpT = 0;
      player.duckUntil = 0;
      startTs = performance.now();
      lastTs = startTs;
      gameState.value = "play";
      spawnObstacle();
      loop(startTs);
    };

    const endGame = () => {
      finalScore.value = Math.max(0, Math.floor(distance));
      gameState.value = "end";
      cancelAnimationFrame(rafId);
      clearTimeout(obstacleTimerId);
    };

    // --- Генерация препятствий ----------------------------------------------
    function spawnObstacle() {
      const typeList = ["gap", "box", "bar"]; // разрыв, коробка, низкая перекладина
      const type = typeList[Math.floor(Math.random() * typeList.length)];
      const w = window.innerWidth;

      const baseGap = 1100;
      const jitter = 650 + Math.random() * 850;
      const spacing = Math.max(650, baseGap - speed * 50 + jitter);

      const width =
        type === "gap" ? (60 + Math.random() * 35) :
        type === "box" ? (36 + Math.random() * 10) :
                         (50 + Math.random() * 8);

      obstacles.push({ type, x: w + 60, width });
      obstacleTimerId = setTimeout(spawnObstacle, spacing);
    }

    // --- Рендер --------------------------------------------------------------
    const drawBackground = (w, h) => {
      // Простой градиент: минимум деталей
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, "#87CEFA");
      grad.addColorStop(1, "#A0A0A0");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      // Рейл по центру
      ctx.fillStyle = "#666";
      ctx.fillRect(0, groundY - 3, w, 6);
    };

    const drawPlayer = (x, y) => {
      ctx.save();
      ctx.translate(x, y);

      // Дека
      ctx.fillStyle = "#000";
      ctx.fillRect(-40, -5, 80, 10);
      ctx.fillStyle = "#ff6600";
      ctx.fillRect(-38, -3, 76, 6);

      // Лого Hellride
      ctx.fillStyle = "#fff";
      ctx.font = "bold 10px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("HELLRIDE", 0, -10);

      // Колёса
      ctx.fillStyle = "#555";
      ctx.beginPath();
      ctx.arc(-30, 6, 6, 0, Math.PI * 2);
      ctx.arc( 30, 6, 6, 0, Math.PI * 2);
      ctx.fill();

      // Руль
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(0, -20);
      ctx.lineTo(0, -50);
      ctx.moveTo(-16, -50);
      ctx.lineTo(16, -50);
      ctx.stroke();

      // Райдер — стойка/присед
      if (player.state === "duck") {
        ctx.fillStyle = "#ff6600";
        ctx.fillRect(-10, -58, 20, 18); // голова ниже
        ctx.fillStyle = "#000";
        ctx.fillRect(-14, -40, 28, 26); // корпус "сжат"
      } else {
        ctx.fillStyle = "#ff6600";
        ctx.fillRect(-10, -70, 20, 20); // голова
        ctx.fillStyle = "#000";
        ctx.fillRect(-12, -50, 24, 30); // туловище
      }
      ctx.restore();
    };

    const drawObstacle = (obs) => {
      ctx.fillStyle = "#ff6600";
      if (obs.type === "gap") {
        // Разрыв — "стираем" кусок рейла
        ctx.clearRect(obs.x - obs.width/2, groundY - 4, obs.width, 8);
      } else if (obs.type === "box") {
        ctx.fillRect(obs.x - obs.width/2, groundY - 25, obs.width, 20);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x - obs.width/2, groundY - 25, obs.width, 20);
      } else if (obs.type === "bar") {
        ctx.fillRect(obs.x - obs.width/2, groundY - 78, obs.width, 10);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(obs.x - obs.width/2, groundY - 78, obs.width, 10);
      }
    };

    // --- Физика/логика -------------------------------------------------------
    const playerYByState = () => {
      let y = groundY;
      if (player.state === "jump") {
        y -= Math.sin(Math.PI * player.jumpT) * JUMP_HEIGHT;
      } else if (player.state === "duck") {
        y += 10;
      }
      return y;
    };

    const playerAABB = (x, y) => {
      const width = 70;
      const height = player.state === "duck" ? 45 : 70;
      return { x: x - width/2, y: y - height, w: width, h: height };
    };

    const collideRectRect = (a, b) => {
      return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y);
    };

    const checkCollision = (px, py, obs) => {
      const a = playerAABB(px, py);
      if (obs.type === "gap") {
        const inGapX = (px > obs.x - obs.width/2) && (px < obs.x + obs.width/2);
        if (inGapX && player.state !== "jump") return true;
      } else if (obs.type === "box") {
        const b = { x: obs.x - obs.width/2, y: groundY - 25, w: obs.width, h: 20 };
        if (collideRectRect(a, b)) return true;
      } else if (obs.type === "bar") {
        const b = { x: obs.x - obs.width/2, y: groundY - 78, w: obs.width, h: 10 };
        if (collideRectRect(a, b)) return true;
      }
      return false;
    };

    const loop = (ts) => {
      const w = canvas.value.width = window.innerWidth;
      const h = canvas.value.height = window.innerHeight;
      groundY = h - 110;

      const dt = Math.max(0.001, (ts - lastTs) / 1000);
      lastTs = ts;
      const elapsed = ts - startTs;

      // Усложнение по времени
      const levelNow = Math.floor(elapsed / 10000);
      if (levelNow > speedLevel) {
        speedLevel = levelNow;
        speed += 0.75;
      }

      // Фон и рейл
      ctx.clearRect(0, 0, w, h);
      drawBackground(w, h);

      // Позиция игрока
      const px = w * 0.28;
      if (player.state === "jump") {
        player.jumpT += JUMP_SPEED * dt; // медленнее => дольше в воздухе
        if (player.jumpT >= 1) {
          player.jumpT = 0;
          player.state = "ride";
        }
      }
      // Авто-продление приседа, если сверху рядом "bar"
      if (player.state === "duck") {
        // найдём ближайшую перекладину впереди игрока
        const aheadBar = obstacles.find(o => o.type === "bar" && o.x >= px - 10 && o.x - px < 140);
        if (aheadBar) {
          // продлеваем ещё немного, пока не пройдём
          player.duckUntil = Math.max(player.duckUntil, performance.now() + 220);
        }
        if (performance.now() >= player.duckUntil) {
          player.state = "ride";
        }
      }

      const py = playerYByState();
      drawPlayer(px, py);

      // Препятствия
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        obs.x -= speed;
        drawObstacle(obs);
        if (checkCollision(px, py, obs)) {
          endGame();
          return;
        }
      }
      obstacles = obstacles.filter(o => o.x > -80);

      // Очки = дистанция
      distance += speed * dt * 8.5;
      score.value = Math.max(0, Math.floor(distance));

      if (gameState.value === "play") rafId = requestAnimationFrame(loop);
    };

    // --- Управление ----------------------------------------------------------
    const onKeyDown = (e) => {
      if (gameState.value !== "play") return;
      if (e.key === "ArrowUp" && player.state === "ride") {
        player.state = "jump";
        player.jumpT = 0;
      }
      if (e.key === "ArrowDown" && player.state === "ride") {
        player.state = "duck";
        player.duckUntil = performance.now() + DUCK_DURATION_MS;
      }
    };

    const onTouchStart = (e) => {
      if (gameState.value !== "play") return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchActive = true;
      gestureUsed = false;
    };

    const onTouchMove = (e) => {
      if (gameState.value !== "play" || !touchActive || gestureUsed) return;
      const t = e.touches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const TH = 20;

      if (absY > absX && absY > TH) {
        if (dy < -TH && player.state === "ride") {
          player.state = "jump";
          player.jumpT = 0;
          gestureUsed = true;
        } else if (dy > TH && player.state === "ride") {
          player.state = "duck";
          player.duckUntil = performance.now() + DUCK_DURATION_MS;
          gestureUsed = true;
        }
      }
    };

    const onTouchEnd = () => {
      touchActive = false;
      gestureUsed = false;
    };

    onMounted(() => {
      ctx = canvas.value.getContext("2d");
      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("touchstart", onTouchStart, { passive: true });
      window.addEventListener("touchmove", onTouchMove, { passive: true });
      window.addEventListener("touchend", onTouchEnd, { passive: true });
    });

    onBeforeUnmount(() => {
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("touchstart", onTouchStart);
      window.removeEventListener("touchmove", onTouchMove);
      window.removeEventListener("touchend", onTouchEnd);
      cancelAnimationFrame(rafId);
      clearTimeout(obstacleTimerId);
    });

    return { gameState, score, finalScore, startGame, canvas };
  },
  template: `
    <div style="width:100%;height:100%;position:relative;">
      <canvas ref="canvas"></canvas>

      <div v-if="gameState==='start'">
        <button class="ui-button start-btn" @click="startGame">Играть</button>
      </div>

      <div v-if="gameState==='play'" class="score-display">
        Очки: {{ score }}
      </div>

      <div v-if="gameState==='end'">
        <div class="score-display">Ты проехал {{ finalScore }} метров!</div>
        <button class="ui-button restart-btn" @click="startGame">Играть снова</button>
      </div>
    </div>
  `
}).mount("#app");
</script>
</body>
</html>
